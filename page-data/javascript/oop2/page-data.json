{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/oop2/","result":{"data":{"site":{"siteMetadata":{"title":"Heaeun","author":"Heaeun","siteUrl":"https://yoonhe.github.io","comment":{"disqusShortName":"yoonhe","utterances":"yoonhe/yoonhe.github.io"},"sponsor":{"buyMeACoffeeId":"yoonhe"}}},"markdownRemark":{"id":"b0c08923-ae4a-511f-ab80-da55f059b914","excerpt":"1. OOP(Object Oriented Programming) 01. OOP란? 객체 지향 프로그래밍(이하 OOP)는 컴퓨터 프로그램을 들의 모임으로 파악하고자 하는 프로그래밍의 패러다임 중에 하나이다. 각  들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다. 02. OOP…","html":"<h1 id=\"1-oopobject-oriented-programming\" style=\"position:relative;\"><a href=\"#1-oopobject-oriented-programming\" aria-label=\"1 oopobject oriented programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. OOP(Object Oriented Programming)</h1>\n<h2 id=\"01-oop란\" style=\"position:relative;\"><a href=\"#01-oop%EB%9E%80\" aria-label=\"01 oop란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>01. OOP란?</h2>\n<ul>\n<li>객체 지향 프로그래밍(이하 OOP)는 컴퓨터 프로그램을 <code class=\"language-text\">객체(Object)</code>들의 모임으로 파악하고자 하는 프로그래밍의 패러다임 중에 하나이다.</li>\n<li>각 <code class=\"language-text\">객체(Object)</code> 들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다.</li>\n</ul>\n<h2 id=\"02-oop의-장점\" style=\"position:relative;\"><a href=\"#02-oop%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"02 oop의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>02. OOP의 장점?</h2>\n<p>실제 생활에서 객체들은 객체들의 공통적인 특성을 모아 더 큰 객체의 개념이 되고 다른 객체와 확실하게 구분되는 특성을 가지고 있다. 이를 프로그래밍으로 이용을 하자면</p>\n<ul>\n<li>코드의 재사용성 제공 : 객체의 특성이나 속성을 한 번 정의해 놓으면 해당 객체에 소속되어 있는 모든 객체들의 속성으로 사용할 수 있으므로 재사용성이 높아진다.</li>\n<li>유지보수의 용이 : 한 번만 정의한 것을 수정하면 모든 객체의 속성을 수정할 수 있다.</li>\n<li>신뢰성 증대 : 다양하게 사용된 속성들에 경험이 쌓이면서 신뢰가 축적되기 쉽고 그것을 다시 사용한다면 에러(버그)의 가능성이 줄어든다.</li>\n</ul>\n<h3 id=\"객체-지향-프로그래밍의-중요한-특성은-강한-응집력strong-cohesion과-약한-결합력weak-coupling을-지향한다\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%A4%91%EC%9A%94%ED%95%9C-%ED%8A%B9%EC%84%B1%EC%9D%80-%EA%B0%95%ED%95%9C-%EC%9D%91%EC%A7%91%EB%A0%A5strong-cohesion%EA%B3%BC-%EC%95%BD%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%A0%A5weak-coupling%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%9C%EB%8B%A4\" aria-label=\"객체 지향 프로그래밍의 중요한 특성은 강한 응집력strong cohesion과 약한 결합력weak coupling을 지향한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 프로그래밍의 중요한 특성은 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향한다.</h3>\n<p>🙋‍♀️ 소프트웨어 공학에서 말하는 응집력, 결합력이란?</p>\n<ul>\n<li>응집력(cohesion) : 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도. 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현한다.</li>\n<li>결합력(coupling) : 프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도. 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미한다.</li>\n</ul>\n<p>OOP의 경우 클래스에 하나의 문제 해결을 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향하므로 응집력을 강화하며,<br>\n클래스 간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다.</p>\n<h2 id=\"03-oop-구성-요소\" style=\"position:relative;\"><a href=\"#03-oop-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C\" aria-label=\"03 oop 구성 요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>03. OOP 구성 요소</h2>\n<ol>\n<li>\n<p>클래스(Class)</p>\n<ul>\n<li>같은 종류의 집단에 속하는 속성과 행위를 정의한 것.</li>\n<li>다른 클래스와 독립적으로 디자인해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>객체(Object)</p>\n<ul>\n<li>클래스의 인스턴스(Instance). </li>\n<li>상위 클래스의 속성을 가지고 있으면서 개별적인 특성과 행위(메소드 : Method) 또한 가지고 있다. </li>\n</ul>\n</li>\n<li>\n<p>메서드(Method)</p>\n<ul>\n<li>클래스로부터 생성된 객체를 사용하는 방법. 객체의 속성을 조작하는 데 사용된다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"04-oop-키워드-4가지\" style=\"position:relative;\"><a href=\"#04-oop-%ED%82%A4%EC%9B%8C%EB%93%9C-4%EA%B0%80%EC%A7%80\" aria-label=\"04 oop 키워드 4가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>04. OOP 키워드 4가지</h2>\n<h3 id=\"1-추상화\" style=\"position:relative;\"><a href=\"#1-%EC%B6%94%EC%83%81%ED%99%94\" aria-label=\"1 추상화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 추상화</h3>\n<ul>\n<li>추상화는 객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정을 말한다.</li>\n<li>객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록 한다.</li>\n</ul>\n<h4 id=\"🧚♀️-정리\" style=\"position:relative;\"><a href=\"#%F0%9F%A7%9A%E2%99%80%EF%B8%8F-%EC%A0%95%EB%A6%AC\" aria-label=\"🧚♀️ 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧚‍♀️ 정리</h4>\n<ul>\n<li>이러한 추상화 과정을 통해 이용자들은 프로그래머가 만든 객체를 더 쉽게 사용할 수 있게 된다.  </li>\n<li>추상화를 할 때 주의할 점은 속성 위주가 아닌 동작 위주로 정의하는 작업을 하는 것이다.  </li>\n<li>객체의 동작에 연관이 되지 않는 속성들은 결국은 불필요하다. 따라서 불필요한 속성들을 걸러내기 위해 동작을 먼저 정의하고 동작에 필요한 속성들을 정리하는 것이 좋다.  </li>\n</ul>\n<p><strong>POINT</strong>  👉🏻 어떠한 동작과 속성을 정의하고 불필요한 정의들을 삭제하여 이용자가 편리하게 객체를 이용할 수 있도록 구성한 것이 추상화이다.</p>\n<h3 id=\"2-캡슐화\" style=\"position:relative;\"><a href=\"#2-%EC%BA%A1%EC%8A%90%ED%99%94\" aria-label=\"2 캡슐화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 캡슐화</h3>\n<ul>\n<li>기능과 특성의 모음을 “클래스”라는 “캡슐”에 분류해서 넣는 것을 의미한다.</li>\n<li>캡슐화는 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다.</li>\n</ul>\n<h3 id=\"3-상속---코드의-재사용과-중복제거\" style=\"position:relative;\"><a href=\"#3-%EC%83%81%EC%86%8D---%EC%BD%94%EB%93%9C%EC%9D%98-%EC%9E%AC%EC%82%AC%EC%9A%A9%EA%B3%BC-%EC%A4%91%EB%B3%B5%EC%A0%9C%EA%B1%B0\" aria-label=\"3 상속   코드의 재사용과 중복제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 상속 - 코드의 재사용과 중복제거</h3>\n<ul>\n<li>부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있다.</li>\n<li>기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있다.</li>\n<li>상속관계를 맺으면 자식 객체를 생성할 때 부모 클래스의 속성들을 자동으로 물려받기 때문에 자식 클래스에서 또 정의할 필요가 없다.  </li>\n</ul>\n<p><strong>POINT</strong>  👉🏻 같은 객체를 여러 개 만들어야 하는 경우, 한 번 작성된 코드를 활용하여 동일한 객체를 만들 수 있다.</p>\n<h3 id=\"4-다형성\" style=\"position:relative;\"><a href=\"#4-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"4 다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 다형성</h3>\n<ul>\n<li>부모 클래스로부터 상속을 받은 속성에 대해, 자식 클래스에서 물려받은 속성을 재정의 할 수 있습니다.</li>\n<li>같은 이름의 속성을 유지함으로서, 속성을 사용하기 위한 인터페이스를 유지하고, 메서드 이름을 낭비하지 않는다</li>\n</ul>","frontmatter":{"title":"oop2","date":"December 06, 2019"}}},"pageContext":{"slug":"/javascript/oop2/","previous":{"fields":{"slug":"/javascript/createobject/"},"frontmatter":{"title":"CreateObject","category":"javascript","draft":false}},"next":{"fields":{"slug":"/til/20191206TIL/"},"frontmatter":{"title":"2019-12-06","category":"til","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}