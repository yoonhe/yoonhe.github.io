{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/timecomplexity/","result":{"data":{"site":{"siteMetadata":{"title":"Heaeun","author":"Heaeun","siteUrl":"https://yoonhe.github.io","comment":{"disqusShortName":"yoonhe","utterances":"yoonhe/yoonhe.github.io"},"sponsor":{"buyMeACoffeeId":"yoonhe"}}},"markdownRemark":{"id":"1094e17c-df67-5a57-b45c-4b30205d101c","excerpt":"해당 포스트에 쓰인 모든 이미지의 출처는 코드스테이츠입니다. 주제 시간복잡도가 무엇이고 왜 사용되는지? 각 자료구조별 시간복잡도 분석 1. Complexity Analysis - 복잡도 분석 input n 에 대하여 알고리즘이 문제를 해결하는 데에 얼마나 오랜 시간이 걸리는 지를 분석하는 것 Big-O 표기를 이용하여 정의할 수 있다. O(1) – 상수 시간 : 입력값 n 이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거친다. O(log n) – 로그 시간 : 입력값 n…","html":"<p>해당 포스트에 쓰인 모든 이미지의 출처는 코드스테이츠입니다.</p>\n<h2 id=\"주제\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%A0%9C\" aria-label=\"주제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주제</h2>\n<ol>\n<li>시간복잡도가 무엇이고 왜 사용되는지?</li>\n<li>각 자료구조별 시간복잡도 분석</li>\n</ol>\n<h2 id=\"1-complexity-analysis---복잡도-분석\" style=\"position:relative;\"><a href=\"#1-complexity-analysis---%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B6%84%EC%84%9D\" aria-label=\"1 complexity analysis   복잡도 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Complexity Analysis - 복잡도 분석</h2>\n<ul>\n<li>input n 에 대하여 알고리즘이 문제를 해결하는 데에 얼마나 오랜 시간이 걸리는 지를 분석하는 것</li>\n<li>\n<p>Big-O 표기를 이용하여 정의할 수 있다.</p>\n<ol>\n<li>O(1) – 상수 시간 : 입력값 n 이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거친다.</li>\n<li>O(log n) – 로그 시간 : 입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.</li>\n<li>O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다.</li>\n<li>O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.</li>\n<li>O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱이다.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"왜-중요한가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%A4%91%EC%9A%94%ED%95%9C%EA%B0%80\" aria-label=\"왜 중요한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 중요한가?</h2>\n<ul>\n<li>자료구조 메소드들의 시간복잡도가 무엇인지 생각을 하면서 상황에 더 맞는 답인지 아닌지를 알고 사용하는 것이 중요하다.</li>\n<li>각각의 데이터구조 장, 단점을 알아야 데이터구조를 효율적으로 사용할 수 있다.</li>\n<li>문제를 해결하려고 할 때마다 시간복잡도를 분석하는 습관을 들이는 것이 중요하다.</li>\n</ul>\n<h2 id=\"시간복잡도-예제\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%98%88%EC%A0%9C\" aria-label=\"시간복잡도 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간복잡도 예제</h2>\n<p>숫자의 배열에서 두 수의 차가 가장 큰 것을 찾는 문제</p>\n<h3 id=\"1-모든-경우의-수를-확인하는-방법---n²--on²\" style=\"position:relative;\"><a href=\"#1-%EB%AA%A8%EB%93%A0-%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95---n%C2%B2--on%C2%B2\" aria-label=\"1 모든 경우의 수를 확인하는 방법   n²  on² permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 모든 경우의 수를 확인하는 방법 - n² => O(n²)</h3>\n<p><img src=\"https://images.velog.io/post-images/yhe228/3a060e10-1fd2-11ea-b5aa-f7315714169a/image.png\" alt=\"image.png\"></p>\n<h3 id=\"2-가장-큰-수와-작은-수를-확인하는-방법---2n--on\" style=\"position:relative;\"><a href=\"#2-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98%EC%99%80-%EC%9E%91%EC%9D%80-%EC%88%98%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95---2n--on\" aria-label=\"2 가장 큰 수와 작은 수를 확인하는 방법   2n  on permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 가장 큰 수와 작은 수를 확인하는 방법 - 2n => O(n)</h3>\n<p><img src=\"https://images.velog.io/post-images/yhe228/c44b16b0-1fd2-11ea-b240-73bff097bbe8/image.png\" alt=\"image.png\"></p>\n<h3 id=\"3-값이-정렬된-경우일-때-오름차순일-경우---3--o1\" style=\"position:relative;\"><a href=\"#3-%EA%B0%92%EC%9D%B4-%EC%A0%95%EB%A0%AC%EB%90%9C-%EA%B2%BD%EC%9A%B0%EC%9D%BC-%EB%95%8C-%EC%98%A4%EB%A6%84%EC%B0%A8%EC%88%9C%EC%9D%BC-%EA%B2%BD%EC%9A%B0---3--o1\" aria-label=\"3 값이 정렬된 경우일 때 오름차순일 경우   3  o1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 값이 정렬된 경우일 때 (오름차순일 경우) - 3 => O(1)</h3>\n<ul>\n<li>최고로 빠른 시간 복잡도를 가진다.</li>\n<li>가장 큰 수에서 가장 작은 수를 빼면 된다</li>\n<li>\n<p>숫자의 개수와 상관없이 항상 3번 계산</p>\n<ol>\n<li>맨 앞에 숫자를 뽑고</li>\n<li>맨 뒤의 숫자를 뽑고</li>\n<li>두개의 숫자를 빼준다</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"요약---big-o-notation\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD---big-o-notation\" aria-label=\"요약   big o notation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약 - Big-O Notation</h2>\n<h3 id=\"1-constant--o1\" style=\"position:relative;\"><a href=\"#1-constant--o1\" aria-label=\"1 constant  o1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. constant : O(1)</h3>\n<p><img src=\"https://images.velog.io/post-images/yhe228/458e49d0-1f02-11ea-bb32-855d58f2234e/image.png\" alt=\"image.png\">  </p>\n<ul>\n<li>문제의 크기가 커져도 걸리는 시간은 항상 일정하다.</li>\n<li>값을 검색할 때, 객체에서 키를 알거나 배열에서 인덱스를 알고 있으면 언제나 한 단계만 걸린다.</li>\n<li>ex) 배열에서 특정 인덱스 탐색, 해시테이블에서 추가</li>\n</ul>\n<h3 id=\"2-logarithmic--olog-n\" style=\"position:relative;\"><a href=\"#2-logarithmic--olog-n\" aria-label=\"2 logarithmic  olog n permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. logarithmic : O(log n)</h3>\n<p><img src=\"https://images.velog.io/post-images/yhe228/60a80080-1f02-11ea-b3f4-e73280e2e0cc/image.png\" alt=\"image.png\">  </p>\n<ul>\n<li>배열에서 값을 찾을 때, 어느 쪽에서 시작할지를 알고 있으면 검색하는 시간이 두배로 준다.</li>\n<li>ex) 이진탐색트리 </li>\n</ul>\n<h3 id=\"3-linear--on\" style=\"position:relative;\"><a href=\"#3-linear--on\" aria-label=\"3 linear  on permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. linear : O(n)</h3>\n<p><img src=\"https://images.velog.io/post-images/yhe228/81530a00-1f02-11ea-bb32-855d58f2234e/image.png\" alt=\"image.png\">  </p>\n<ul>\n<li>데이터의 갯수만큼 탐색할 경우</li>\n<li>linked list, Array 탐색</li>\n</ul>\n<h3 id=\"4-quadratic--on²\" style=\"position:relative;\"><a href=\"#4-quadratic--on%C2%B2\" aria-label=\"4 quadratic  on² permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. quadratic : O(n²)</h3>\n<p><img src=\"https://images.velog.io/post-images/yhe228/9402d270-1f02-11ea-bb32-855d58f2234e/image.png\" alt=\"image.png\"> </p>\n<ul>\n<li>문제를 풀기 위해 모든 조합과 방법을 시도할 때 사용된다.</li>\n<li>for문 안에 for문</li>\n</ul>\n<h3 id=\"5-esponential--oc²\" style=\"position:relative;\"><a href=\"#5-esponential--oc%C2%B2\" aria-label=\"5 esponential  oc² permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. esponential : O(c²)</h3>\n<p><img src=\"https://images.velog.io/post-images/yhe228/b70e6130-1f02-11ea-9142-41013861be0a/image.png\" alt=\"image.png\"></p>\n<ul>\n<li>recursion에서 memoiz기법을 사용하지 않았을때</li>\n</ul>\n<h2 id=\"data-structure-with-time-complexity\" style=\"position:relative;\"><a href=\"#data-structure-with-time-complexity\" aria-label=\"data structure with time complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data structure With Time Complexity</h2>\n<p>Array, linked list, Trees의 Time Complexity</p>\n<h3 id=\"1-arrays\" style=\"position:relative;\"><a href=\"#1-arrays\" aria-label=\"1 arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Arrays</h3>\n<ul>\n<li>값 조회(Lookup, index 사용) => O(1)</li>\n<li>값 할당(Assignment) => O(1)</li>\n<li>\n<p>값 추가(insert) => O(n)</p>\n<ul>\n<li>추가한 값의 뒤에 위치하는 값들을 모두 뒤로 당겨줘야한다.</li>\n</ul>\n</li>\n<li>\n<p>값 삭제(remove) => O(n)</p>\n<ul>\n<li>삭제한 값의 뒤에 위치하는 값들을 모두 앞으로 당겨줘야한다.</li>\n</ul>\n</li>\n<li>\n<p>값 조회(Find, value 사용) => O(n)</p>\n<ul>\n<li>모든 값들을 돌면서 찾고있는 값과 동일한지 비교해야한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-linked-list\" style=\"position:relative;\"><a href=\"#2-linked-list\" aria-label=\"2 linked list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Linked List</h3>\n<ul>\n<li>값 조회(Lookup, index 사용) => O(n)</li>\n<li>\n<p>값 할당(Assignment) => O(n)</p>\n<ul>\n<li>head부터 시작해서 해당 index까지 count를 해주어야 한다.</li>\n</ul>\n</li>\n<li>\n<p>값 조회(Find, value 사용) => O(n)</p>\n<ul>\n<li>head부터 시작해서 찾는 value가 나올때 까지 비교해야 한다.</li>\n</ul>\n</li>\n<li>값 추가(insert) => O(1)</li>\n<li>\n<p>값 삭제(remove)</p>\n<ul>\n<li>head => O(1)</li>\n<li>\n<p>middle => O(n)</p>\n<ul>\n<li>삭제하려는 값의 이전값을 모르기때문에 삭제하려는 값이 next로 담긴 값까지 탐색해야함</li>\n<li>단, 이전값(prev)를 참조하는 Doubly-Linked-Lists를 사용하면 복잡도는 O(1)이다.</li>\n<li>Doubly-Linked-Lists가 Linked-Lists보다 참조하는 주소값이 많으므로 메모리는 더 많이 차지한다. </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-tree\" style=\"position:relative;\"><a href=\"#3-tree\" aria-label=\"3 tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Tree</h3>\n<p>Root Node => children</p>\n<ul>\n<li>값 조회(Find, value 사용) => O(n)</li>\n<li>값 할당(Assignment) => O(n)</li>\n<li>값 추가(insert) => O(1)</li>\n<li>값 삭제(remove)   </li>\n</ul>\n<h3 id=\"4-binary-search-tree\" style=\"position:relative;\"><a href=\"#4-binary-search-tree\" aria-label=\"4 binary search tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Binary Search Tree</h3>\n<p>Root Node => children => Left (OR) Right</p>\n<ul>\n<li>값 조회(Find, value 사용) => O(log n)</li>\n</ul>\n<p>❗ 예외 케이스 ❗<br>\n한쪽으로만 값이 몰릴 경우 => O(n)<br>\n<img src=\"https://images.velog.io/post-images/yhe228/7cb56720-1fe0-11ea-8629-d51f99813324/image.png\" alt=\"image.png\"></p>\n<p><strong>[ 위의 경우를 방지하기 위한 Solution ]</strong>  </p>\n<ol>\n<li>각 Parents의 왼쪽, 오른쪽 가지들의 깊이가 1을 초과하여 차이가 난다면 밸런스가 무너진 상태</li>\n<li>밸런스가 무너질 때 마다 가지의 깊이가 더 깊은 쪽의 값을 얕은 쪽으로 이동시킨다.</li>\n<li>이렇게 하면 트리의 복잡도는 항상 O(log n)</li>\n</ol>\n<p><img src=\"https://images.velog.io/post-images/yhe228/c817f4d0-1fe0-11ea-8629-d51f99813324/image.png\" alt=\"image.png\"> </p>\n<h2 id=\"정렬된-배열-vs-이진탐색트리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC%EB%90%9C-%EB%B0%B0%EC%97%B4-vs-%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC\" aria-label=\"정렬된 배열 vs 이진탐색트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정렬된 배열 vs 이진탐색트리</h2>\n<p><code class=\"language-text\">Array</code>는 연속된 공간을 차지하지만,<br>\n<code class=\"language-text\">Tree</code>를 Linked List를 사용하여 구성하게 되면 공간을 연속적으로 차지하지 않고 메모리 구석구석에 위치할 수 있어서 메모리를 효율적으로 사용할 수 있다.</p>\n<p>💁‍♀️ <a href=\"https://joshuajangblog.wordpress.com/2016/09/21/time_complexity_big_o_in_easy_explanation/\">참고블로그</a></p>","frontmatter":{"title":"timeComplexity","date":"December 16, 2019"}}},"pageContext":{"slug":"/algorithm/timecomplexity/","previous":{"fields":{"slug":"/algorithm/treeMap/"},"frontmatter":{"title":"Tree Map Mathod","category":"algorithm","draft":false}},"next":{"fields":{"slug":"/javascript/subclassing /"},"frontmatter":{"title":"Subclassing","category":"javascript","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}